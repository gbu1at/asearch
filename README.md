В данной небольшой статье я хочу затронуть тему поиска кратчайших путей на графах
Опять же тут не будет ничего нового, просто небольшрй ликбез по тому, что люди уже придумали и реализовали
Начем с формулирови задачи
Предположим у нас есть граф, с вершинками и ребрами на нем
Нам бы хотелось найти минимальное расстояние между двумя вершинами s и t
Это можно сделать несколькими способами
Самым известным является алгоритм Дейсктры

----
Давайте вспомним как он работает
Алгоритм Дейкстры начинается с установки начальной вершины и работы от этой точки. Он работает по принципу «жадного» алгоритма, что означает, что на каждом шаге он стремится минимизировать текущую общую стоимость пути.

Сначала инициализируются два множества:
Множество, содержащее уже обработанные вершины (изначально пустое).
Множество, содержащее все остальные вершины графа (изначально содержит все вершины графа).

Также каждой вершине графа присваивается вес, который представляет минимальную известную стоимость пути от начальной вершины до данной. Для начальной вершины этот вес равен 0, для всех остальных вершин — бесконечность.

На каждом шаге алгоритм выбирает вершину из непосещенного множества с наименьшим весом, перемещает эту вершину в множество посещенных вершин и обновляет веса всех соседей выбранной вершины. Вес соседа обновляется, если через выбранную вершину можно добраться до этого соседа с меньшей стоимостью.

Процесс продолжается, пока не будут посещены все вершины или пока мы не найдем путь до конечной вершины t.
----

Окей, а есть ли что-то еще?

Да, можно например запустить дейкстру из обеих вершин
Этот алгоритм называется Bidirectional Dijkstra
Реализация его абсолютно такая же как в dijkstra, но теперь шаг за шагом мы поочередно вызываем dijksta для двух вершин s и t
Это может быть полезно, если мы хотим найти минимальное расстояние между вершинами в "дорожном" графе
на картике проиллюстрирован принцип работы, а также интуитивное понимание, почему этот алгоритм может оказаться лучше dijkstra в некоторых ситуациях
если оценить количесвто итераций исходя из площади круга радиуса r
то можно приблизительно оценить насколько флгоритм bidirectional dijkstra лучше

S1 = pi * (2r)**2
S2 = 2 * pi * r

На дорожных картах мы уверенно выигрываем по скорости в 2 раза, используя для поиска пути Bidirectional dijkstra


Но не во всех ситуациях Bidirectional dijkstra оптимальный алгоритм
Приведем пример
Пусть у нас есть n вершин
Можно себе представить, что наши врешинки расположены по кругу и соеденены с соседями ребром веса 1
При этом вершины s и t соседние и между ними вес n / 2
если мы запустим dijkstra из вершинки s, то мы за n/2 шагов справимся найти минимальный путь до вершинки t
Но при реализации bidirectional dijkstra нам необходимо будет суммарно произвести n итераций


Опять же из иллюстрации мы можем видеть, что не все так гладко
Очень странно на дорожных картах при построении маршрута с запада на восток учитывать города, расположенные западнее s
Вряд ли кратцайший путь будет проходить через них

Поэтому плавно перейдем к следуюшему алгоритму и рассмотрим его ключевую идею
Это A*

Алгоритм A* работает на основе оценки стоимости пути до цели. Эта стоимость вычисляется как сумма двух компонент:

g(x) — это уже известная стоимость пути от начальной вершины до x.
h(x) — это эвристическая оценка стоимости пути от x до t. Главное, чтобы h(x) было строго меньше, чем минимальное расстояние от x до t!
Это ключевой момент!
Сумма f(x) = g(x) + h(x) дает оценку общей стоимости пути через данную вершину. Эвристика h(x) играет ключевую роль в алгоритме A*. Она должна быть адекватной, чтобы алгоритм был эффективным.

На каждом шаге алгоритм выбирает вершину с наименьшей оценкой f(x) из списка открытых вершин (вершин, которые уже были обнаружены, но еще не обработаны), затем смотрит на соседей этой вершины и обновляет их стоимости g(y), если через текущую вершину можно добраться до них быстрее. Если вершина еще не была открыта, она добавляется в список открытых вершин.

Алгоритм работает абсолютно также, как dijkstra, но с небольшим отличием в виде выбора функции f(x), вместо обычного расстояния g(x)

Процесс продолжается, пока вершинка t не станет обработанной
То есть в тот момент, когда f(t) минимально среди всех открытых вершин

Взглянем на картинку:


В качестве h здесь используется евклидово расстояние между городами

Математически несложно показать, что данный алгоритм строго лучше dijkstra 
ведь не существует такой вершинки u, которую мы обработали в алгоритме a*, но при этом упустили в djkstra 
Это следует из выбора функии h(x) - она всегда меньше реального расстояние от x до t

